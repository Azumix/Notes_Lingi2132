\chapter{PEG \& CFG Semantics}
\label{chap:peg_cfg_semantics}

\section{Recap}
    \theoremstyle{definition}
    \begin{definition}[Grammar]
        The (formal) definition of a language
    \end{definition}
    \theoremstyle{definition}
    \begin{definition}[Language]
        A (potentially infinite) set of sentences
    \end{definition}
    \theoremstyle{definition}
    \begin{definition}[Parser]
        Recognizes a sentence in the language + extract a syntax tree
    \end{definition}
    \theoremstyle{definition}
    \begin{definition}[Parsing Tool]
        Generate and/or runs parsers
    \end{definition}
    Two types of formalisms : 
    \begin{itemize}
        \item CFG (Context-Free-Grammar)
        \item PEF (Parsing Expression Grammar)
    \end{itemize}
    Notations : 
        \begin{itemize}
            \item (E)BNF (usually for CFG)
            \item PEG Notation (usually for PEG)
        \end{itemize}
    \theoremstyle{definition}
    \begin{definition}[Non-Terminal]
        Things that we define
    \end{definition}
    \theoremstyle{definition}
    \begin{definition}[Terminals]
        Tokens, strings, etc. that cannot be extended further.
    \end{definition}

\section{Context-Free Grammars}
    Usually a CFG is defined as a tuple of 4 components Grammar = $(N, \Sigma, P, S)$: 
        \begin{itemize}
            \item N: Non-Terminals
            \item $\Sigma$: Alphabet (Terminals)
            \item P: Production Rules ($P: N \rightarrow (\Sigma \cup N)*$)
            \item Starting Symbol ($S \in N$)
        \end{itemize}

    In order to have a CFG from a "full" grammar, we first need to replace all
    syntactic sugars by the complete recursive rules, then eliminate all choices
    by introducing as many rules as we have choices.

    \subsection{Semantics Derivation}
        \begin{itemize}
            \item The language defined by a CFG is the set of all sentences that
            can be derived from its rules
            \item Start from the start symbol, replace it by the right-hand side
            of one its production
            \item At each step, replace a non-terminal from the current string
            symbol by its definition (until no non-terminals are left in the string)
            \item Any terminal, the order does not matter
        \end{itemize}
        Note that by doing that, we define the language, not a parsing algorithm
        and we're doing it in a generative way grammar $\rightarrow$ sentences.

        Also, if we would have used characters derivation instead of tokens we
        would have need to continue to derive which would of potentially lead to
        an infinite derivation. So, we can say that for a sentence to be part of
        a language in need to be derivable however we cannot describe the all
        derivation table because in many case, it would be infinite.
\section{PEG Semantics}
    We can see in the slide (9 of PEG - CFG semantics's pdf) the use of a
    top-down recursive descent parsers that produce production rules (with
    lookahead operator as an exception).

\section{PEG vs CFG}
    \subsection{Semantics}
        CFG are generative (their semantics is given by constructing the language
        set by the grammar through derivation). On the other hand PEG are
        recognition based : a sentence is in the language defined by a PEG grammar
        only if it is recognized by the language recognizer. In order to formalize
        PEG grammar we need to formalize the recognizer for the grammar.

        These two approaches are very different in the mathematical point of view.
        Also, CFG is easier to defined in the mathematical language, on the other
        hand the PEG is very much related to the practice.
    \subsection{The difference}
        \begin{itemize}
            \item CFG has unordered choices, while derivating we can pick any
            non-terminal we want
            \item PEG has ordered choices, the first matching is the "correct"
            one
        \end{itemize}
    \subsection{The big difference}